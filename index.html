<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Aether Weaver</title>
    <style>
        /* --- General Body & Game Container Styling --- */
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Clean, modern font */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(to bottom, #1a0033, #0d0d1a); /* Deep space gradient */
            color: #e6e6ff; /* Soft white/purple text */
            overflow: hidden; /* Prevent scrollbars */
            -webkit-user-select: none; /* Disable text selection for better game feel */
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: none; /* Crucial: Prevents browser scrolling/zooming on touch */
        }

        #game-container {
            width: 80vw;
            max-width: 500px; /* Portrait phone size focus */
            height: 90vh;
            max-height: 750px;
            border: 4px solid #6a0dad; /* Mystical border */
            background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent game background */
            position: relative;
            box-shadow: 0 0 30px rgba(106, 0, 173, 0.8); /* Strong glow */
            display: flex;
            flex-direction: column;
            border-radius: 15px;
            overflow: hidden; /* Ensure orbs don't render outside */
        }

        /* --- Game Screens (Start, Pause, Level Complete, Game Over) --- */
        .game-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.95);
            text-align: center;
            z-index: 100; /* Always on top */
            border-radius: 12px; /* Match container */
            padding: 20px;
            box-sizing: border-box;
        }

        .hidden {
            display: none !important;
        }

        /* --- Buttons & Input --- */
        button {
            padding: 12px 28px;
            margin: 12px;
            font-size: 1.35em;
            cursor: pointer;
            background-color: #9932cc; /* Purple accent */
            color: white;
            border: 2px solid #ce93d8;
            border-radius: 8px;
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            outline: none; /* Remove focus outline */
        }

        button:hover {
            background-color: #a042d3;
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.5);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
        }

        input[type="text"] {
            padding: 12px;
            margin-bottom: 25px;
            border: 2px solid #ce93d8;
            border-radius: 8px;
            font-size: 1.2em;
            width: 80%;
            max-width: 280px;
            background-color: #2a0040;
            color: #e6e6ff;
            text-align: center;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            outline: none;
        }

        /* --- Game Play Screen Layout --- */
        #game-play-screen {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: stretch;
            padding: 10px;
            box-sizing: border-box;
            background-color: transparent; /* Allows gradient background to show */
        }

        #game-info {
            display: flex;
            justify-content: space-around;
            width: 100%;
            padding: 10px 0;
            font-size: 1.1em;
            background-color: rgba(0,0,0,0.6);
            border-radius: 8px;
            margin-bottom: 10px;
            z-index: 10;
        }

        #current-target-color {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            padding: 8px 0;
            background-color: rgba(0,0,0,0.6);
            border-radius: 8px;
            margin-bottom: 10px;
            z-index: 10;
            font-size: 1.2em;
            text-align: center;
        }

        #current-target-color .orb-sample {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            margin-left: 10px;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
            border: 2px solid rgba(255,255,255,0.2);
            transition: all 0.2s ease-out; /* For changing color */
        }

        #game-area {
            flex-grow: 1;
            position: relative;
            overflow: hidden; /* Crucial for preventing orbs from drawing outside */
            background-color: transparent;
            border-radius: 8px;
            cursor: pointer; /* Indicates interaction */
            touch-action: none; /* Again, crucial for mobile */
        }

        /* --- Collector --- */
        #collector {
            position: absolute;
            bottom: 0px; /* Sit right at the bottom edge */
            left: 50%;
            transform: translateX(-50%);
            width: 120px; /* Base width */
            height: 30px;
            background: linear-gradient(to right, #6a0dad, #9932cc, #6a0dad);
            border-radius: 15px 15px 0 0; /* Rounded top, flat bottom */
            box-shadow: 0 0 20px #9932cc, inset 0 0 10px rgba(255,255,255,0.5);
            z-index: 50; /* On top of falling orbs */
            transition: width 0.3s ease, box-shadow 0.3s ease; /* For size/power change */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8em;
            opacity: 0.9;
        }

        #collector .collector-effect {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 20px solid #ce93d8; /* Triangle pointing up */
            opacity: 0;
            animation: pulseEffect 1s infinite alternate;
        }

        @keyframes pulseEffect {
            0% { transform: scale(0.8); opacity: 0.5; }
            100% { transform: scale(1.2); opacity: 0.8; }
        }


        /* --- Aether Orbs (Falling Objects) --- */
        .aether-orb {
            position: absolute;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            transition: opacity 0.2s ease-out, transform 0.2s ease-out; /* For destruction */
            box-shadow: 0 0 15px rgba(255,255,255,0.7); /* Subtle glow */
            border: 2px solid rgba(255,255,255,0.3);
            z-index: 20;
        }

        /* Orb Colors */
        .orb-red { background-color: #ff0000; }
        .orb-blue { background-color: #0000ff; }
        .orb-green { background-color: #00ff00; }
        .orb-yellow { background-color: #ffff00; }
        .orb-purple { background-color: #800080; }

        /* Orb Destruction Effect */
        .aether-orb.destroyed {
            opacity: 0;
            transform: scale(0.1);
        }

        /* --- Aether Path (Drawn by player) --- */
        #aether-path-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 40; /* Above orbs, below collector */
            pointer-events: none; /* Don't block interaction with elements below */
            overflow: hidden;
        }

        .aether-path-segment {
            position: absolute;
            background-color: rgba(200, 100, 255, 0.7); /* Glowing purple path */
            box-shadow: 0 0 10px #c864ff;
            height: 5px; /* Thickness of the path */
            transform-origin: 0 0; /* For rotation */
            transition: background-color 0.1s ease; /* For color change on wrong orb */
        }

        .aether-path-segment.wrong-orb-hit {
            background-color: rgba(255, 50, 50, 0.8);
            box-shadow: 0 0 10px #ff3232;
        }

        /* --- Level Specific Elements (Final Orb) --- */
        .final-orb {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: gold;
            box-shadow: 0 0 25px gold, inset 0 0 10px rgba(255,255,0,0.8);
            z-index: 60; /* Higher than other orbs */
            animation: rotateGold 5s linear infinite;
        }

        @keyframes rotateGold {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* --- Pause Button (always visible during gameplay) --- */
        #controls {
            display: flex;
            justify-content: center;
            width: 100%;
            padding: 8px 0;
            margin-top: 10px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 8px;
            z-index: 10;
        }
        #controls button {
            padding: 8px 15px;
            font-size: 1.1em;
            margin: 0;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="start-screen" class="game-screen">
            <h1>Aether Weaver</h1>
            <p>Enter your Weaver Name:</p>
            <input type="text" id="playerNameInput" placeholder="Aether Seeker">
            <button id="startButton">Begin Weaving</button>
        </div>

        <div id="game-play-screen" class="game-screen hidden">
            <div id="game-info">
                <p>Weaver: <span id="playerNameDisplay"></span></p>
                <p>Essence: <span id="scoreDisplay">0</span></p>
                <p>Focus: <span id="livesDisplay">3</span></p>
                <p>Realm: <span id="levelDisplay">1</span></p>
            </div>
            <div id="current-target-color">
                Collect: <span id="targetColorText"></span> <div class="orb-sample" id="targetColorOrb"></div>
            </div>
            <div id="game-area">
                <div id="aether-path-container"></div>
                <div id="collector"></div>
            </div>
            <div id="controls">
                <button id="pauseButton">Pause</button>
            </div>
        </div>

        <div id="pause-screen" class="game-screen hidden">
            <h1>Weaving Paused</h1>
            <button id="continueButton">Resume Weaving</button>
            <button id="restartButtonPause">Start Over</button>
        </div>

        <div id="level-complete-screen" class="game-screen hidden">
            <h1 id="levelCompleteMessage">Realm 1 Stabilized!</h1>
            <p>Excellent work, <span id="levelCompletePlayerName"></span>!</p>
            <button id="nextLevelButton">Weave to Next Realm</button>
        </div>

        <div id="game-over-screen" class="game-screen hidden">
            <h1>AETHER STORM!</h1>
            <p id="finalScoreMessage">Essence Collected: <span id="finalScoreDisplay">0</span></p>
            <button id="restartButtonGameOver">Re-attune</button>
        </div>
    </div>

    <script>
        /* --- Game State Variables --- */
        let playerName = '';
        let score = 0;
        let lives = 3;
        let level = 1;
        let gameRunning = false;
        let gamePaused = false;
        let gameLoopAnimationFrame; // For requestAnimationFrame
        let orbGenerationInterval;
        let collectorPower = 0; // Increases magnetic pull/size of collector
        const MAX_COLLECTOR_POWER = 100; // Max value for collector power

        let targetColors = ['blue']; // Current target colors for the level
        let collectedTargetOrbs = 0; // How many target orbs collected this level

        const activeOrbs = []; // Array to hold active orb elements
        let currentAetherPath = []; // Stores the segments of the drawn path

        // --- DOM Elements ---
        const gameContainer = document.getElementById('game-container');
        const startScreen = document.getElementById('start-screen');
        const gamePlayScreen = document.getElementById('game-play-screen');
        const pauseScreen = document.getElementById('pause-screen');
        const levelCompleteScreen = document.getElementById('level-complete-screen');
        const gameOverScreen = document.getElementById('game-over-screen');

        const playerNameInput = document.getElementById('playerNameInput');
        const startButton = document.getElementById('startButton');

        const playerNameDisplay = document.getElementById('playerNameDisplay');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const livesDisplay = document.getElementById('livesDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const targetColorText = document.getElementById('targetColorText');
        const targetColorOrb = document.getElementById('targetColorOrb');
        const gameArea = document.getElementById('game-area');
        const collector = document.getElementById('collector');
        const aetherPathContainer = document.getElementById('aether-path-container');
        const pauseButton = document.getElementById('pauseButton');

        const continueButton = document.getElementById('continueButton');
        const restartButtonPause = document.getElementById('restartButtonPause');

        const levelCompleteMessage = document.getElementById('levelCompleteMessage');
        const levelCompletePlayerName = document.getElementById('levelCompletePlayerName');
        const nextLevelButton = document.getElementById('nextLevelButton');

        const finalScoreDisplay = document.getElementById('finalScoreDisplay');
        const restartButtonGameOver = document.getElementById('restartButtonGameOver');

        // --- Game Settings (Adjust for difficulty) ---
        const ORB_COLORS = ['red', 'blue', 'green', 'yellow', 'purple'];
        const ORB_SIZE = 35; // px
        const PATH_SEGMENT_LENGTH = 15; // How long each path segment is drawn
        const COLLECTOR_BASE_WIDTH = 120; // Initial width of collector
        const COLLECTOR_POWER_EFFECT_MULTIPLIER = 0.5; // How much collector power adds to width

        const LEVEL_SETTINGS = {
            1: {
                orbSpeed: 1.5, generationRate: 1800, orbsToCollect: 10,
                targetColors: ['blue'], orbTypes: ['blue', 'red', 'green']
            },
            2: {
                orbSpeed: 2.0, generationRate: 1500, orbsToCollect: 15,
                targetColors: ['blue'], orbTypes: ['blue', 'red', 'green', 'yellow']
            },
            3: {
                orbSpeed: 2.2, generationRate: 1300, orbsToCollect: 20,
                targetColors: ['blue', 'green'], orbTypes: ['blue', 'green', 'red', 'yellow', 'purple']
            },
            4: {
                orbSpeed: 2.5, generationRate: 1100, orbsToCollect: 25,
                targetColors: ['red', 'yellow'], orbTypes: ['blue', 'green', 'red', 'yellow', 'purple']
            },
            5: { // Aether Storm
                orbSpeed: 3.0, generationRate: 900, orbsToCollect: 30,
                targetColors: ['blue', 'red', 'green'], orbTypes: ['blue', 'green', 'red', 'yellow', 'purple']
            }
        };

        const SCORE_PER_ORB = 10;
        const PENALTY_FOR_WRONG_ORB = 20; // Points lost for destroying wrong orb
        const FOCUS_LOSS_PER_MISS = 1; // Lives lost for missing any orb
        const MAX_LEVEL = 5;

        let lastPathPoint = null; // Stores coordinates of the last drawn path segment end
        let isDrawingPath = false; // Is the player currently holding down to draw?
        let isOrbMovingToCollector = false; // Is an orb currently being drawn to collector?

        // --- Utility Functions ---
        function showScreen(screenElement) {
            document.querySelectorAll('.game-screen').forEach(screen => {
                screen.classList.add('hidden');
            });
            screenElement.classList.remove('hidden');
        }

        function updateDisplay() {
            playerNameDisplay.textContent = playerName;
            scoreDisplay.textContent = score;
            livesDisplay.textContent = lives;
            levelDisplay.textContent = level;

            const currentSettings = LEVEL_SETTINGS[level];
            if (currentSettings) {
                targetColorText.textContent = currentSettings.targetColors.map(c => c.charAt(0).toUpperCase() + c.slice(1)).join(' & ');
                // For simplicity, just show the first target color in the orb sample
                targetColorOrb.className = `orb-sample orb-${currentSettings.targetColors[0]}`;
            }
        }

        function createAetherSparkle(x, y, color = '#e0e0ff', type = 'collection') {
            const sparkle = document.createElement('div');
            sparkle.style.position = 'absolute';
            sparkle.style.left = `${x}px`;
            sparkle.style.top = `${y}px`;
            sparkle.style.width = '10px';
            sparkle.style.height = '10px';
            sparkle.style.borderRadius = '50%';
            sparkle.style.backgroundColor = color;
            sparkle.style.boxShadow = `0 0 15px ${color}, 0 0 5px ${color}`;
            sparkle.style.opacity = '1';
            sparkle.style.zIndex = '90';
            sparkle.style.transform = `translate(-50%, -50%) scale(0.1)`;
            sparkle.style.transition = 'all 0.4s ease-out';

            gameArea.appendChild(sparkle);

            // Animate
            requestAnimationFrame(() => {
                sparkle.style.transform = `translate(-50%, -50%) scale(${type === 'collection' ? 1.5 : 0.8})`;
                sparkle.style.opacity = '0';
            });

            setTimeout(() => sparkle.remove(), 400);
        }

        // --- Game Logic Functions ---

        function startGame() {
            playerName = playerNameInput.value.trim();
            if (playerName === '') {
                alert('Please enter your Weaver Name!');
                return;
            }
            score = 0;
            lives = 3;
            level = 1;
            collectedTargetOrbs = 0;
            activeOrbs.length = 0; // Clear any existing objects
            aetherPathContainer.innerHTML = ''; // Clear existing paths
            gameArea.querySelectorAll('.aether-orb, .final-orb').forEach(el => el.remove());

            collectorPower = 0; // Reset collector power
            updateCollectorSize(); // Reset collector size

            showScreen(gamePlayScreen);
            gameRunning = true;
            gamePaused = false;
            updateDisplay();
            startLevel();
        }

        function startLevel() {
            collectedTargetOrbs = 0;
            activeOrbs.length = 0;
            aetherPathContainer.innerHTML = ''; // Clear paths from previous level
            gameArea.querySelectorAll('.aether-orb, .final-orb').forEach(el => el.remove());

            const currentSettings = LEVEL_SETTINGS[level];
            if (!currentSettings) {
                endGame(true); // Win if no more levels
                return;
            }

            targetColors = [...currentSettings.targetColors]; // Set new target colors for the level

            clearInterval(orbGenerationInterval);
            orbGenerationInterval = setInterval(generateOrb, currentSettings.generationRate);

            if (gameLoopAnimationFrame) {
                cancelAnimationFrame(gameLoopAnimationFrame); // Stop previous loop if running
            }
            gameLoop(); // Start game loop for new level
            updateDisplay(); // Update target color display
        }

        function pauseGame() {
            if (!gameRunning) return;
            gamePaused = true;
            showScreen(pauseScreen);
            clearInterval(orbGenerationInterval);
            cancelAnimationFrame(gameLoopAnimationFrame);
        }

        function continueGame() {
            gamePaused = false;
            showScreen(gamePlayScreen);
            const currentSettings = LEVEL_SETTINGS[level];
            orbGenerationInterval = setInterval(generateOrb, currentSettings.generationRate);
            gameLoop(); // Resume animation frame loop
        }

        function restartGame() {
            clearInterval(orbGenerationInterval);
            cancelAnimationFrame(gameLoopAnimationFrame);
            startGame(); // Simply restart from the beginning
        }

        function endGame(win = false) {
            gameRunning = false;
            gamePaused = false;
            clearInterval(orbGenerationInterval);
            cancelAnimationFrame(gameLoopAnimationFrame);

            // Clean up all remaining game objects
            gameArea.querySelectorAll('.aether-orb, .final-orb, .aether-path-segment').forEach(el => el.remove());
            activeOrbs.length = 0; // Clear array

            if (win) {
                if (level > MAX_LEVEL) { // All levels truly completed
                    levelCompleteMessage.textContent = "All Realms Stabilized! Master Weaver!";
                    levelCompletePlayerName.textContent = playerName;
                    nextLevelButton.textContent = "Weave Again?";
                    nextLevelButton.onclick = restartGame;
                } else { // Current level completed, going to next
                    levelCompleteMessage.textContent = `Realm ${level} Stabilized!`;
                    levelCompletePlayerName.textContent = playerName;
                    nextLevelButton.textContent = "Weave to Next Realm";
                    nextLevelButton.onclick = nextLevel;
                }
                showScreen(levelCompleteScreen);

            } else {
                finalScoreDisplay.textContent = score;
                showScreen(gameOverScreen);
            }
        }

        function generateOrb() {
            if (!gameRunning || gamePaused) return;

            const currentSettings = LEVEL_SETTINGS[level];
            const orbColor = currentSettings.orbTypes[Math.floor(Math.random() * currentSettings.orbTypes.length)];

            const orb = document.createElement('div');
            orb.className = `aether-orb orb-${orbColor}`;
            orb.dataset.color = orbColor;
            orb.dataset.state = 'falling'; // 'falling', 'collecting', 'destroyed'
            orb.style.left = `${Math.random() * (gameArea.offsetWidth - ORB_SIZE)}px`;
            orb.style.top = `-50px`; // Start above the screen
            gameArea.appendChild(orb);
            activeOrbs.push(orb);
        }

        function updateOrbs() {
            const currentSettings = LEVEL_SETTINGS[level];
            const collectorRect = collector.getBoundingClientRect();
            const gameAreaRect = gameArea.getBoundingClientRect();

            // Loop backwards for safe removal
            for (let i = activeOrbs.length - 1; i >= 0; i--) {
                const orb = activeOrbs[i];
                if (!gameArea.contains(orb) || orb.dataset.state === 'destroyed') {
                    activeOrbs.splice(i, 1);
                    continue;
                }

                let currentTop = parseFloat(orb.style.top);
                let currentLeft = parseFloat(orb.style.left);

                if (orb.dataset.state === 'falling') {
                    orb.style.top = `${currentTop + currentSettings.orbSpeed}px`;

                    // Check if orb went off screen (missed)
                    if (currentTop > gameArea.offsetHeight) {
                        lives--;
                        updateDisplay();
                        createAetherSparkle(orb.offsetLeft + ORB_SIZE / 2, orb.offsetTop + ORB_SIZE / 2, '#dc3545', 'miss');
                        orb.remove();
                        activeOrbs.splice(i, 1);
                        if (lives <= 0) {
                            endGame();
                            return;
                        }
                    }
                } else if (orb.dataset.state === 'collecting') {
                    // Move orb towards the center of the collector
                    const collectorCenterX = collector.offsetLeft + collector.offsetWidth / 2;
                    const collectorCenterY = collector.offsetTop + collector.offsetHeight / 2;

                    const orbCenterX = currentLeft + ORB_SIZE / 2;
                    const orbCenterY = currentTop + ORB_SIZE / 2;

                    const dx = collectorCenterX - orbCenterX;
                    const dy = collectorCenterY - orbCenterY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    const COLLECT_SPEED = currentSettings.orbSpeed * 3 + (collectorPower / MAX_COLLECTOR_POWER) * 5; // Faster based on collector power

                    if (distance < COLLECT_SPEED) { // Close enough to snap to collector
                        collectOrb(orb);
                    } else {
                        orb.style.left = `${currentLeft + (dx / distance) * COLLECT_SPEED}px`;
                        orb.style.top = `${currentTop + (dy / distance) * COLLECT_SPEED}px`;
                    }
                }
            }
        }

        function collectOrb(orb) {
            const orbColor = orb.dataset.color;
            orb.remove();
            activeOrbs.splice(activeOrbs.indexOf(orb), 1); // Remove from activeOrbs array

            if (targetColors.includes(orbColor)) {
                score += SCORE_PER_ORB;
                collectedTargetOrbs++;
                createAetherSparkle(collector.offsetLeft + collector.offsetWidth / 2, collector.offsetTop + collector.offsetHeight / 2, orbColor, 'collection');
                increaseCollectorPower();
            } else {
                // This scenario shouldn't happen with the current logic (wrong orbs are destroyed by path)
                // but as a fallback, if a wrong orb somehow gets collected, penalize.
                lives--;
                updateDisplay();
                createAetherSparkle(collector.offsetLeft + collector.offsetWidth / 2, collector.offsetTop + collector.offsetHeight / 2, '#dc3545', 'miss');
                if (lives <= 0) {
                    endGame();
                }
            }
            updateDisplay();
            checkLevelCompletion();
        }

        function increaseCollectorPower() {
            collectorPower = Math.min(MAX_COLLECTOR_POWER, collectorPower + 2); // Increase by 2 for each correct orb
            updateCollectorSize();
        }

        function updateCollectorSize() {
            const newWidth = COLLECTOR_BASE_WIDTH + (collectorPower * COLLECTOR_POWER_EFFECT_MULTIPLIER);
            collector.style.width = `${newWidth}px`;
            collector.style.left = `calc(50% - ${newWidth / 2}px)`; // Re-center
        }

        function checkLevelCompletion() {
            const currentSettings = LEVEL_SETTINGS[level];
            if (collectedTargetOrbs >= currentSettings.orbsToCollect) {
                advanceLevelOrWin();
            }
        }

        function advanceLevelOrWin() {
            gameRunning = false;
            clearInterval(orbGenerationInterval);
            cancelAnimationFrame(gameLoopAnimationFrame);

            if (level < MAX_LEVEL) {
                showScreen(levelCompleteScreen);
            } else {
                endGame(true); // All levels completed, you win!
            }
        }

        function nextLevel() {
            level++;
            if (level > MAX_LEVEL) {
                endGame(true);
                return;
            }
            showScreen(gamePlayScreen);
            gameRunning = true;
            gamePaused = false;
            updateDisplay(); // Update display for new level
            startLevel();
        }

        // --- Aether Path Drawing Logic ---
        let pathStartX = 0;
        let pathStartY = 0;
        let drawingTimeout = null; // Timeout to clear path if no orb is touched

        function startPathDrawing(clientX, clientY) {
            if (!gameRunning || gamePaused) return;

            isDrawingPath = true;
            lastPathPoint = {
                x: clientX - gameArea.getBoundingClientRect().left,
                y: clientY - gameArea.getBoundingClientRect().top
            };

            // Clear any old path segments
            currentAetherPath.forEach(seg => seg.remove());
            currentAetherPath = [];

            // Find closest orb to start the path
            const startOrb = findClosestOrb(lastPathPoint.x, lastPathPoint.y);
            if (startOrb) {
                // Adjust start point to be from the orb's center
                lastPathPoint.x = startOrb.offsetLeft + ORB_SIZE / 2;
                lastPathPoint.y = startOrb.offsetTop + ORB_SIZE / 2;
                orbToWeave = startOrb; // Set the orb that is being drawn
                orbToWeave.dataset.state = 'collecting';
                isOrbMovingToCollector = true; // Flag that an orb is being collected
            } else {
                // If no orb near start, just start drawing from touch point
                orbToWeave = null;
            }

            // Set a timeout to clear the path if it's not connected to an orb or released quickly
            clearTimeout(drawingTimeout);
            drawingTimeout = setTimeout(clearAetherPath, 500); // Clear after 0.5s if nothing happens
        }


        function drawPathSegment(clientX, clientY) {
            if (!isDrawingPath || !gameRunning || gamePaused) return;

            const gameAreaRect = gameArea.getBoundingClientRect();
            const currentX = clientX - gameAreaRect.left;
            const currentY = clientY - gameAreaRect.top;

            const distance = Math.sqrt(Math.pow(currentX - lastPathPoint.x, 2) + Math.pow(currentY - lastPathPoint.y, 2));

            if (distance < PATH_SEGMENT_LENGTH) {
                // Don't draw too many tiny segments
                return;
            }

            // Calculate angle and length for the segment
            const angle = Math.atan2(currentY - lastPathPoint.y, currentX - lastPathPoint.x);
            const length = distance;

            const segment = document.createElement('div');
            segment.className = 'aether-path-segment';
            segment.style.left = `${lastPathPoint.x}px`;
            segment.style.top = `${lastPathPoint.y}px`;
            segment.style.width = `${length}px`;
            segment.style.transform = `rotate(${angle}rad)`;
            aetherPathContainer.appendChild(segment);
            currentAetherPath.push(segment);

            lastPathPoint = { x: currentX, y: currentY };

            // Check for orb collisions with the new path segment
            checkPathOrbCollisions(segment);
        }

        function endPathDrawing() {
            isDrawingPath = false;
            isOrbMovingToCollector = false; // Reset orb collection state
            clearAetherPath(); // Clear all path segments
            clearTimeout(drawingTimeout); // Clear any pending clear timeout
        }

        function clearAetherPath() {
            currentAetherPath.forEach(seg => seg.remove());
            currentAetherPath = [];
            lastPathPoint = null;
        }

        let orbToWeave = null; // The orb currently being influenced by the path

        function findClosestOrb(x, y) {
            let closestOrb = null;
            let minDistance = Infinity;

            for (const orb of activeOrbs) {
                if (orb.dataset.state !== 'falling') continue; // Only consider falling orbs

                const orbCenterX = orb.offsetLeft + ORB_SIZE / 2;
                const orbCenterY = orb.offsetTop + ORB_SIZE / 2;
                const distance = Math.sqrt(Math.pow(x - orbCenterX, 2) + Math.pow(y - orbCenterY, 2));

                if (distance < minDistance && distance < 70) { // Only consider orbs within a certain radius
                    minDistance = distance;
                    closestOrb = orb;
                }
            }
            return closestOrb;
        }

        function checkPathOrbCollisions(pathSegment) {
            const pathRect = pathSegment.getBoundingClientRect();
            const gameAreaRect = gameArea.getBoundingClientRect();

            const pathRelRect = {
                left: pathRect.left - gameAreaRect.left,
                right: pathRect.right - gameAreaRect.left,
                top: pathRect.top - gameAreaRect.top,
                bottom: pathRect.bottom - gameAreaRect.top
            };

            for (let i = activeOrbs.length - 1; i >= 0; i--) {
                const orb = activeOrbs[i];
                if (orb.dataset.state !== 'falling' && orb.dataset.state !== 'collecting') continue; // Already handled or destroyed

                const orbRect = orb.getBoundingClientRect();
                const orbRelRect = {
                    left: orbRect.left - gameAreaRect.left,
                    right: orbRect.right - gameAreaRect.left,
                    top: orbRect.top - gameAreaRect.top,
                    bottom: orbRect.bottom - gameAreaRect.top
                };

                // Simple AABB collision check
                if (
                    pathRelRect.left < orbRelRect.right &&
                    pathRelRect.right > orbRelRect.left &&
                    pathRelRect.top < orbRelRect.bottom &&
                    pathRelRect.bottom > orbRelRect.top
                ) {
                    // Collision detected!
                    clearTimeout(drawingTimeout); // An orb was hit, keep path visible for a moment

                    if (targetColors.includes(orb.dataset.color)) {
                        // Correct orb hit, start collecting if not already
                        if (orb.dataset.state === 'falling') {
                            orb.dataset.state = 'collecting';
                        }
                    } else {
                        // Wrong orb hit, destroy it and penalize
                        if (orb.dataset.state !== 'destroyed') {
                            score = Math.max(0, score - PENALTY_FOR_WRONG_ORB); // Don't go below zero
                            updateDisplay();
                            createAetherSparkle(orb.offsetLeft + ORB_SIZE / 2, orb.offsetTop + ORB_SIZE / 2, '#ff3232', 'destruction');
                            orb.classList.add('destroyed');
                            orb.dataset.state = 'destroyed';
                            pathSegment.classList.add('wrong-orb-hit'); // Visually indicate wrong hit
                            setTimeout(() => {
                                if (gameArea.contains(orb)) orb.remove();
                                const orbIndex = activeOrbs.indexOf(orb);
                                if (orbIndex > -1) activeOrbs.splice(orbIndex, 1);
                            }, 200); // Remove after short delay for animation
                            endPathDrawing(); // End path on wrong hit
                            return; // Don't process other orbs with this segment
                        }
                    }
                }
            }
        }


        // --- Game Loop (requestAnimationFrame for smooth animations) ---
        function gameLoop() {
            if (!gameRunning || gamePaused) return;

            updateOrbs();

            gameLoopAnimationFrame = requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---

        // Start Screen
        startButton.addEventListener('click', startGame);
        playerNameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') startGame();
        });

        // Game Play Screen - Touch/Mouse Interactions
        gameArea.addEventListener('mousedown', (e) => {
            startPathDrawing(e.clientX, e.clientY);
        });

        gameArea.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevents scrolling/zooming
            if (e.touches.length > 0) {
                startPathDrawing(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });

        gameArea.addEventListener('mousemove', (e) => {
            drawPathSegment(e.clientX, e.clientY);
        });

        gameArea.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevents scrolling/zooming
            if (e.touches.length > 0) {
                drawPathSegment(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });

        document.addEventListener('mouseup', endPathDrawing);
        document.addEventListener('touchend', endPathDrawing);
        document.addEventListener('touchcancel', endPathDrawing); // Handle when touch leaves screen

        // Pause Button
        pauseButton.addEventListener('click', pauseGame);

        // Pause Screen
        continueButton.addEventListener('click', continueGame);
        restartButtonPause.addEventListener('click', restartGame);

        // Level Complete Screen
        nextLevelButton.addEventListener('click', nextLevel);

        // Game Over Screen
        restartButtonGameOver.addEventListener('click', restartGame);

        // Initial setup
        showScreen(startScreen);
        updateDisplay();
        updateCollectorSize(); // Initial collector size
    </script>
</body>
</html>
